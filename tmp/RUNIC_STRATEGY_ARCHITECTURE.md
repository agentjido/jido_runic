# Jido.Runic.Strategy — Architecture Design

## The Insight

ActionNode wrapping a single Jido Action is the wrong abstraction level for
agent integration. The right seam is between **planning** (pure, inside `cmd/2`)
and **execution** (effectful, behind directives).

ReAct already solved this problem. Its Machine is a pure state machine that emits
symbolic directives (`{:exec_tool, id, name, args}`). The Strategy lifts those
into concrete `Directive.ToolExec` structs. Execution happens in the directive
executor, never in `cmd/2`.

Runic should follow the same pattern: the workflow DAG is the planner, Runnables
become Instructions, and execution flows through Jido's directive system.

---

## Two Modes of Operation

### Mode 1: Standalone (existing, keep as-is)

Runic + ActionNode used directly with `react_until_satisfied`. ActionNode's
`Invokable.execute/2` calls `Jido.Exec.run/4` inline. No agent, no directives,
no purity constraints. Good for scripts, pipelines, one-shot batch processing.

```elixir
workflow
|> Workflow.react_until_satisfied(%{order_id: "123"})
|> Workflow.raw_productions()
```

### Mode 2: Agent Strategy (new)

Runic as a `Jido.Agent.Strategy`. The workflow lives in `agent.state.__strategy__`.
`cmd/2` only plans and applies — never executes. Execution flows through directives.

```
Signal → AgentServer → Strategy.cmd/2
  cmd/2 (PURE):
    1. Convert signal data → Fact
    2. plan_eagerly(workflow, fact) → updated workflow
    3. prepare_for_dispatch(workflow) → {workflow, [runnables]}
    4. Convert each runnable → %Instruction{} (pure data transform)
    5. Wrap each instruction → Directive.RunInstruction (or Directive.RunRunnable)
    6. Return {agent_with_updated_workflow, directives}

DirectiveExec (EFFECTFUL):
    7. For each directive → Jido.Exec.run(instruction) under TaskSupervisor
    8. On completion → emit "runic.runnable.completed" signal back to agent

Signal → Strategy.cmd/2 (completion handler):
    9. Build result Fact from completion signal
   10. apply_runnable(workflow, result) → updated workflow
   11. If workflow still runnable → goto step 3
   12. If satisfied → extract productions → emit result signals
```

---

## Directives

### `Jido.Runic.Directive.RunInstruction`

The primary directive. Converts a Runic Runnable into a Jido Instruction and
asks the runtime to execute it.

```elixir
defmodule Jido.Runic.Directive.RunInstruction do
  @moduledoc """
  Execute a Jido Instruction derived from a Runic Runnable.

  The strategy converts each Runnable into an Instruction (pure data transform)
  and wraps it in this directive. The runtime executes the instruction via
  `Jido.Exec.run/1` and sends the result back as a completion signal.

  This is the Runic equivalent of `Jido.AI.Directive.ToolExec` — both describe
  "run this action and tell me when it's done."
  """

  # Fields:
  #   runnable_id  - Stable hash for correlation (from Runnable)
  #   node_hash    - Hash of the ActionNode that produced this runnable
  #   instruction  - %Jido.Instruction{} ready for Jido.Exec.run/1
  #   workflow_id  - Which workflow instance this belongs to (for multi-workflow agents)
  #   metadata     - Causal context, ancestry depth, etc.
end
```

**Why Instruction, not raw action_mod + params?**
- `Jido.Exec.run/1` accepts `%Instruction{}` directly — canonical execution path
- Instruction carries `{action, params, context, opts}` as one unit
- Same struct used by Direct strategy, FSM strategy, now Runic strategy
- Serializable, inspectable, loggable

### `Jido.Runic.Directive.RunRunnableRemote`

For multi-agent workflows where a Runnable should execute on a child agent.

```elixir
defmodule Jido.Runic.Directive.RunRunnableRemote do
  @moduledoc """
  Dispatch a Runnable to a child agent for execution.

  Used when the ActionNode's executor tag points to a child agent. The strategy
  emits this directive, and the runtime either:
  1. Sends a signal to an existing child (if already spawned)
  2. Spawns a new child via SpawnAgent + sends the signal
  """

  # Fields:
  #   runnable_id  - Correlation ID
  #   instruction  - %Jido.Instruction{} for the child to execute
  #   executor_tag - Atom tag mapping to a child agent (e.g., :source_scout)
  #   spawn_spec   - Optional: agent module to spawn if child doesn't exist
end
```

### `Jido.Runic.Directive.EmitProductions`

When the workflow reaches satisfaction, emit the leaf productions as signals.

```elixir
defmodule Jido.Runic.Directive.EmitProductions do
  @moduledoc """
  Emit Runic workflow productions as Jido Signals.

  Generated by the strategy when the workflow reaches satisfaction.
  Each production Fact becomes a Signal with provenance metadata.
  """

  # Fields:
  #   productions  - List of Fact values to emit
  #   signal_type  - Base type for production signals (e.g., "runic.production")
  #   source       - Signal source path (e.g., "/runic/order_pipeline")
  #   workflow_id  - Workflow instance that produced these
end
```

---

## ActionNode's New Role

ActionNode stays, but gains a pure data-transform method. Its existing
`Invokable.execute/2` remains for standalone mode.

```elixir
defmodule Jido.Runic.ActionNode do
  # ... existing struct and new/3 ...

  @doc """
  Convert a Runnable (from prepare phase) into a Jido Instruction.

  Pure function — no execution, no I/O. Used by the Runic Strategy
  to build directives inside cmd/2.
  """
  @spec to_instruction(t(), Runic.Workflow.Fact.t()) :: Jido.Instruction.t()
  def to_instruction(%__MODULE__{} = node, %Fact{} = input_fact) do
    merged_params = Map.merge(node.params, to_params(input_fact.value))

    Jido.Instruction.new!(%{
      action: node.action_mod,
      params: merged_params,
      context: node.context,
      opts: node.exec_opts
    })
  end

  defp to_params(%Jido.Signal{data: data}) when is_map(data), do: data
  defp to_params(value) when is_map(value), do: value
  defp to_params(value), do: %{input: value}
end
```

The Invokable impl's `execute/2` still calls `Jido.Exec.run/4` directly — that's
the standalone path. The Strategy never calls it.

---

## Strategy Implementation Sketch

```elixir
defmodule Jido.Runic.Strategy do
  use Jido.Agent.Strategy

  alias Jido.Agent
  alias Jido.Agent.Strategy.State, as: StratState
  alias Jido.Runic.ActionNode
  alias Runic.Workflow
  alias Runic.Workflow.Fact

  # ── Signals ──────────────────────────────────────────────────

  @impl true
  def signal_routes(_ctx) do
    [
      {"runic.input", {:strategy_cmd, :runic_input}},
      {"runic.runnable.completed", {:strategy_cmd, :runic_completed}},
      {"runic.runnable.failed", {:strategy_cmd, :runic_failed}}
    ]
  end

  # ── Init ─────────────────────────────────────────────────────

  @impl true
  def init(agent, ctx) do
    opts = ctx[:strategy_opts] || []
    workflow = Keyword.fetch!(opts, :workflow)

    state = %{
      status: :idle,
      workflow: workflow,
      in_flight: %{},       # runnable_id => {node_hash, input_fact}
      productions: []
    }

    agent = StratState.put(agent, state)
    {agent, []}
  end

  # ── Input signal: start workflow ─────────────────────────────

  @impl true
  def cmd(agent, [{:runic_input, params}], _ctx) do
    state = StratState.get(agent, %{})
    input_fact = Fact.new(value: params)

    workflow =
      state.workflow
      |> Workflow.plan_eagerly(input_fact)

    {workflow, directives, in_flight} = prepare_and_dispatch(workflow, state.in_flight)

    new_state = %{state |
      status: :running,
      workflow: workflow,
      in_flight: in_flight
    }

    agent = StratState.put(agent, new_state)
    {agent, directives}
  end

  # ── Completion signal: apply result, continue ────────────────

  def cmd(agent, [{:runic_completed, %{runnable_id: rid, result: result}}], _ctx) do
    state = StratState.get(agent, %{})

    case Map.pop(state.in_flight, rid) do
      {nil, _} ->
        # Unknown runnable — ignore (idempotency)
        {agent, []}

      {{node_hash, input_fact}, remaining_in_flight} ->
        result_fact = Fact.new(
          value: result,
          ancestry: {node_hash, input_fact.hash}
        )

        workflow =
          state.workflow
          |> apply_completed_runnable(node_hash, input_fact, result_fact)

        if Workflow.is_runnable?(workflow) do
          {workflow, directives, in_flight} =
            prepare_and_dispatch(workflow, remaining_in_flight)

          new_state = %{state |
            workflow: workflow,
            in_flight: in_flight
          }

          agent = StratState.put(agent, new_state)
          {agent, directives}
        else
          # Workflow satisfied — extract productions
          productions = Workflow.raw_productions(workflow)

          new_state = %{state |
            status: :completed,
            workflow: workflow,
            in_flight: remaining_in_flight,
            productions: productions,
            result: productions
          }

          agent = StratState.put(agent, new_state)
          {agent, production_directives(productions)}
        end
    end
  end

  # ── Failure signal ───────────────────────────────────────────

  def cmd(agent, [{:runic_failed, %{runnable_id: rid, error: error}}], _ctx) do
    state = StratState.get(agent, %{})
    {_, remaining} = Map.pop(state.in_flight, rid)

    new_state = %{state |
      status: :error,
      in_flight: remaining,
      result: {:error, error}
    }

    agent = StratState.put(agent, new_state)
    error_directive = %Jido.Agent.Directive.Error{
      error: Jido.Runic.Error.execution_error("Runnable failed", %{
        runnable_id: rid, error: error
      }),
      context: :runic_execution
    }
    {agent, [error_directive]}
  end

  # ── Private ──────────────────────────────────────────────────

  defp prepare_and_dispatch(workflow, in_flight) do
    {workflow, runnables} = Workflow.prepare_for_dispatch(workflow)

    {directives, new_in_flight} =
      Enum.reduce(runnables, {[], in_flight}, fn runnable, {dirs, flight} ->
        node = runnable.node
        fact = runnable.input_fact
        rid = runnable_id(runnable)

        instruction = ActionNode.to_instruction(node, fact)

        directive = %Jido.Runic.Directive.RunInstruction{
          runnable_id: rid,
          node_hash: node.hash,
          instruction: instruction
        }

        {[directive | dirs], Map.put(flight, rid, {node.hash, fact})}
      end)

    {workflow, Enum.reverse(directives), new_in_flight}
  end

  defp apply_completed_runnable(workflow, node_hash, input_fact, result_fact) do
    node = find_node_by_hash(workflow, node_hash)

    workflow
    |> Workflow.log_fact(result_fact)
    |> Workflow.draw_connection(node, result_fact, :produced)
    |> Workflow.mark_runnable_as_ran(node, input_fact)
    |> Workflow.prepare_next_runnables(node, result_fact)
  end

  defp production_directives(productions) do
    Enum.map(productions, fn value ->
      signal = Jido.Signal.new!(
        "runic.production",
        value,
        source: "/runic/workflow"
      )
      %Jido.Agent.Directive.Emit{signal: signal}
    end)
  end

  defp runnable_id(runnable) do
    :erlang.phash2({runnable.node.hash, runnable.input_fact.hash})
  end

  defp find_node_by_hash(workflow, hash) do
    # Walk workflow graph to find node by hash
    # (implementation depends on Runic's graph access API)
  end
end
```

---

## DirectiveExec Implementation

```elixir
defimpl Jido.AgentServer.DirectiveExec, for: Jido.Runic.Directive.RunInstruction do
  @moduledoc """
  Executes a Runic Runnable as a Jido Instruction.

  Spawns an async task that:
  1. Calls Jido.Exec.run/1 with the instruction
  2. On success → emits "runic.runnable.completed" signal back to agent
  3. On failure → emits "runic.runnable.failed" signal back to agent

  Follows the same pattern as Jido.AI.Directive.ToolExec.
  """

  def exec(directive, _input_signal, state) do
    %{runnable_id: rid, instruction: instruction} = directive
    agent_pid = self()

    task_sup =
      if state.jido, do: Jido.task_supervisor_name(state.jido), else: Jido.TaskSupervisor

    Task.Supervisor.start_child(task_sup, fn ->
      result =
        try do
          Jido.Exec.run(instruction)
        rescue
          e -> {:error, Exception.message(e)}
        end

      signal = case result do
        {:ok, value} ->
          Jido.Signal.new!(
            "runic.runnable.completed",
            %{runnable_id: rid, result: value},
            source: "/runic/executor"
          )

        {:error, reason} ->
          Jido.Signal.new!(
            "runic.runnable.failed",
            %{runnable_id: rid, error: reason},
            source: "/runic/executor"
          )
      end

      Jido.AgentServer.cast(agent_pid, signal)
    end)

    {:async, nil, state}
  end
end
```

---

## Comparison with ReAct

| Aspect | ReAct | Runic Strategy |
|--------|-------|----------------|
| Pure state core | `ReAct.Machine` (Fsmx) | `Runic.Workflow` (DAG) |
| State shape | Linear: idle → awaiting_llm → awaiting_tool → completed | Graph: arbitrary DAG with joins, fan-out, conditions |
| Symbolic directives | `{:exec_tool, id, name, args}` | Runnables from `prepare_for_dispatch` |
| Concrete directives | `Directive.ToolExec`, `Directive.LLMStream` | `Directive.RunInstruction`, `Directive.RunRunnableRemote` |
| Completion signals | `"react.tool.result"`, `"react.llm.response"` | `"runic.runnable.completed"`, `"runic.runnable.failed"` |
| Execution | `Jido.Exec.run` in DirectiveExec | `Jido.Exec.run` in DirectiveExec |
| cmd/2 purity | Machine.update is pure | Workflow.plan/apply are pure |
| Where I/O happens | DirectiveExec for ToolExec, LLMStream | DirectiveExec for RunInstruction |

The parallel is exact. ReAct's Machine manages a linear state machine; Runic's
Workflow manages a DAG. Both emit symbolic "here's what to run next" descriptions
that the Strategy lifts into concrete directives. Both keep `cmd/2` pure.

---

## What ActionNode Becomes

ActionNode is **not wrong** — it's just not an executor in agent mode. It's a
**descriptor**: stable identity, schema introspection, graph composition, and
serialization. Its roles:

1. **Graph composition**: `Workflow.add(node)`, `Workflow.add(node, to: :other)`
2. **Stable hashing**: content-addressed from `{action_mod, params, name}`
3. **Schema introspection**: `Component.inputs/outputs` for type checking
4. **Instruction factory**: `to_instruction(node, fact)` → `%Instruction{}`
5. **Standalone execution**: `Invokable.execute/2` for non-agent pipelines
6. **Serialization**: `Component.source/1` returns reconstructable AST

Roles 1-4 are used by the Strategy. Role 5 is standalone mode. Role 6 is persistence.

---

## Signals

Define these as custom signal types via `use Jido.Signal`:

```elixir
defmodule Jido.Runic.Signal.RunnableCompleted do
  use Jido.Signal,
    type: "runic.runnable.completed",
    default_source: "/runic/executor",
    schema: [
      runnable_id: [type: :integer, required: true],
      result: [type: :any, required: true]
    ]
end

defmodule Jido.Runic.Signal.RunnableFailed do
  use Jido.Signal,
    type: "runic.runnable.failed",
    default_source: "/runic/executor",
    schema: [
      runnable_id: [type: :integer, required: true],
      error: [type: :any, required: true]
    ]
end
```

---

## Updated Build Order

### Phase 1: Foundation (done)
- [x] ActionNode struct + Invokable/Component/Transmutable impls
- [x] All 25 tests passing

### Phase 2: ActionNode Enhancement (1 day)
- [ ] Add `to_instruction/2` to ActionNode (pure data transform)
- [ ] Add Signal-aware `to_params` (extract `signal.data` from Signal values)
- [ ] Tests for `to_instruction`

### Phase 3: Directives (1 day)
- [ ] `Jido.Runic.Directive.RunInstruction` struct
- [ ] `DirectiveExec` protocol impl (async exec + completion signal)
- [ ] `Jido.Runic.Signal.RunnableCompleted` / `RunnableFailed`
- [ ] Tests for directive execution round-trip

### Phase 4: Strategy (2-3 days)
- [ ] `Jido.Runic.Strategy` — init, cmd (input + completed + failed), snapshot
- [ ] `signal_routes` for completion/failure signals
- [ ] `in_flight` tracking for runnable correlation
- [ ] Tests: single-node workflow end-to-end through strategy
- [ ] Tests: multi-node pipeline through strategy
- [ ] Tests: fan-out/join through strategy

### Phase 5: Multi-Agent (2 days)
- [ ] `Jido.Runic.Directive.RunRunnableRemote`
- [ ] Child agent spawning + signal dispatch
- [ ] Tests: orchestrator + child agent workflow

### Phase 6: Polish (1-2 days)
- [ ] `EmitProductions` directive
- [ ] Serialization round-trip
- [ ] Error handling / timeout via `tick/2`
- [ ] Introspection (provenance chain query)
- [ ] Documentation

---

## What We Dropped

- **SignalFact module** — unnecessary. Signals flow as fact values naturally.
  `to_params` handles extraction.
- **ExecuteRunnable as the primary directive** — replaced by `RunInstruction`.
  Instructions are the canonical Jido primitive for "work to be done."
  Runnables are a Runic internal; Instructions are Jido's lingua franca.
- **Direct execution in cmd/2** — the whole point. `cmd/2` plans, directives execute.

## What We Kept

- **ActionNode** — descriptor + standalone executor + instruction factory
- **Three-phase execution** — Runic's prepare/execute/apply maps perfectly.
  Prepare + apply happen in `cmd/2`. Execute happens behind directives.
- **Provenance** — Fact ancestry is continuous. Each completion signal carries
  enough context to reconstruct the result Fact with correct ancestry.
